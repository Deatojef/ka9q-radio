\doxysection{channel Struct Reference}
\hypertarget{structchannel}{}\label{structchannel}\index{channel@{channel}}


radiod channel state block  




{\ttfamily \#include $<$radio.\+h$>$}



Collaboration diagram for channel\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=303pt]{structchannel__coll__graph}
\end{center}
\end{figure}
\doxysubsubsection*{Data Fields}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{structchannel_a86034da20b5c9d4aa3c00711f4dbb0f5}\label{structchannel_a86034da20b5c9d4aa3c00711f4dbb0f5} 
bool {\bfseries inuse}
\item 
\Hypertarget{structchannel_a4a1f9593fd895e5bac467dd602e997ce}\label{structchannel_a4a1f9593fd895e5bac467dd602e997ce} 
int {\bfseries lifetime}
\item 
\Hypertarget{structchannel_a468e560b67561a951dd411feefdb6c08}\label{structchannel_a468e560b67561a951dd411feefdb6c08} 
\begin{tabbing}
xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=\kill
struct \{\\
\>double {\bfseries freq}\\
\>double {\bfseries shift}\\
\>double {\bfseries second\_LO}\\
\>double {\bfseries doppler}\\
\>double {\bfseries doppler\_rate}\\
\} {\bfseries tune}\\

\end{tabbing}\item 
\Hypertarget{structchannel_ac00fdef57ad6f43f384472c074d3a0e9}\label{structchannel_ac00fdef57ad6f43f384472c074d3a0e9} 
struct \mbox{\hyperlink{structosc}{osc}} fine {\bfseries shift}
\item 
\Hypertarget{structchannel_aa3cd004bc46c8d921ed1adc9673aca19}\label{structchannel_aa3cd004bc46c8d921ed1adc9673aca19} 
\begin{tabbing}
xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=\kill
struct \{\\
\>struct \mbox{\hyperlink{structfilter__out}{filter\_out}} {\bfseries out}\\
\>float {\bfseries min\_IF}\\
\>float {\bfseries max\_IF}\\
\>float {\bfseries kaiser\_beta}\\
\>bool {\bfseries isb}\\
\>float \texorpdfstring{$\ast$}{*} {\bfseries energies}\\
\>int {\bfseries bin\_shift}\\
\>double {\bfseries remainder}\\
\>complex double {\bfseries phase\_adjust}\\
\} {\bfseries filter}\\

\end{tabbing}\item 
\Hypertarget{structchannel_abf719d357b33bccb4476799121647427}\label{structchannel_abf719d357b33bccb4476799121647427} 
enum demod\+\_\+type {\bfseries demod\+\_\+type}
\item 
\Hypertarget{structchannel_a820f1c196de0f2134601db599bf18b3f}\label{structchannel_a820f1c196de0f2134601db599bf18b3f} 
char {\bfseries preset} \mbox{[}32\mbox{]}
\item 
\Hypertarget{structchannel_acd1e36e65184f506f11d6c8794d9bf68}\label{structchannel_acd1e36e65184f506f11d6c8794d9bf68} 
\begin{tabbing}
xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=\kill
struct \{\\
\>bool {\bfseries env}\\
\>bool {\bfseries agc}\\
\>float {\bfseries hangtime}\\
\>float {\bfseries recovery\_rate}\\
\>float {\bfseries threshold}\\
\} {\bfseries linear}\\

\end{tabbing}\item 
\Hypertarget{structchannel_afc9666f6a4ea3337098cb351b0ac8ec9}\label{structchannel_afc9666f6a4ea3337098cb351b0ac8ec9} 
int {\bfseries hangcount}
\item 
\Hypertarget{structchannel_a3ad1aa1913e52a2425d442211245e4f4}\label{structchannel_a3ad1aa1913e52a2425d442211245e4f4} 
\begin{tabbing}
xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=\kill
struct \{\\
\>struct \mbox{\hyperlink{structpll}{pll}} {\bfseries pll}\\
\>bool {\bfseries was\_on}\\
\>int {\bfseries lock\_count}\\
\>bool {\bfseries enable}\\
\>bool {\bfseries square}\\
\>bool {\bfseries lock}\\
\>float {\bfseries loop\_bw}\\
\>float {\bfseries cphase}\\
\>int64\_t {\bfseries rotations}\\
\} {\bfseries pll}\\

\end{tabbing}\item 
\Hypertarget{structchannel_aa9f9877b17a7f4ec2e4ff1a9e5d2f07a}\label{structchannel_aa9f9877b17a7f4ec2e4ff1a9e5d2f07a} 
\begin{tabbing}
xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=\kill
struct \{\\
\>float {\bfseries bb\_power}\\
\>float {\bfseries bb\_energy}\\
\>float {\bfseries foffset}\\
\>float {\bfseries snr}\\
\>float {\bfseries n0}\\
\} {\bfseries sig}\\

\end{tabbing}\item 
\Hypertarget{structchannel_ac8b038fd244f2a04622a1fa891ebb7eb}\label{structchannel_ac8b038fd244f2a04622a1fa891ebb7eb} 
\begin{tabbing}
xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=\kill
struct \{\\
\>float {\bfseries pdeviation}\\
\>float {\bfseries tone\_freq}\\
\>float {\bfseries tone\_deviation}\\
\>bool {\bfseries threshold}\\
\>float {\bfseries squelch\_open}\\
\>float {\bfseries squelch\_close}\\
\>int {\bfseries squelch\_tail}\\
\>float {\bfseries gain}\\
\>float {\bfseries rate}\\
\} {\bfseries fm}\\

\end{tabbing}\item 
\Hypertarget{structchannel_a5051aec9dbc7726052fc7f2c6f394ad5}\label{structchannel_a5051aec9dbc7726052fc7f2c6f394ad5} 
\begin{tabbing}
xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=\kill
struct \{\\
\>float {\bfseries bin\_bw}\\
\>int {\bfseries bin\_count}\\
\>float \texorpdfstring{$\ast$}{*} {\bfseries bin\_data}\\
\} {\bfseries spectrum}\\

\end{tabbing}\item 
\Hypertarget{structchannel_a5184c24243e0af526d2dcb9dd7d90104}\label{structchannel_a5184c24243e0af526d2dcb9dd7d90104} 
\begin{tabbing}
xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=\kill
struct \{\\
\>unsigned int {\bfseries samprate}\\
\>float {\bfseries gain}\\
\>float {\bfseries sum\_gain\_sq}\\
\>float {\bfseries headroom}\\
\>bool {\bfseries silent}\\
\>struct \mbox{\hyperlink{structrtp__state}{rtp\_state}} {\bfseries rtp}\\
\>struct sockaddr\_storage {\bfseries source\_socket}\\
\>struct sockaddr\_storage {\bfseries dest\_socket}\\
\>char {\bfseries dest\_string} \mbox{[}\_POSIX\_HOST\_NAME\_MAX+20\mbox{]}\\
\>unsigned int {\bfseries channels}\\
\>float {\bfseries energy}\\
\>float {\bfseries deemph\_state\_left}\\
\>float {\bfseries deemph\_state\_right}\\
\>uint64\_t {\bfseries samples}\\
\>bool {\bfseries pacing}\\
\>enum encoding {\bfseries encoding}\\
\>OpusEncoder \texorpdfstring{$\ast$}{*} {\bfseries opus}\\
\>unsigned int {\bfseries opus\_channels}\\
\>unsigned int {\bfseries opus\_bitrate}\\
\>float \texorpdfstring{$\ast$}{*} {\bfseries queue}\\
\>size\_t {\bfseries queue\_size}\\
\>unsigned {\bfseries wp}\\
\>unsigned {\bfseries rp}\\
\>unsigned {\bfseries minpacket}\\
\} {\bfseries output}\\

\end{tabbing}\item 
\Hypertarget{structchannel_a472b904c6f1641fc026fff982c9697e2}\label{structchannel_a472b904c6f1641fc026fff982c9697e2} 
\begin{tabbing}
xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=\kill
struct \{\\
\>uint64\_t {\bfseries packets\_in}\\
\>uint32\_t {\bfseries tag}\\
\>pthread\_mutex\_t {\bfseries lock}\\
\>uint64\_t {\bfseries blocks\_since\_poll}\\
\>int {\bfseries global\_timer}\\
\>int {\bfseries output\_timer}\\
\>int {\bfseries output\_interval}\\
\>uint64\_t {\bfseries packets\_out}\\
\>struct sockaddr\_storage {\bfseries dest\_socket}\\
\>uint8\_t \texorpdfstring{$\ast$}{*} {\bfseries command}\\
\>int {\bfseries length}\\
\} {\bfseries status}\\

\end{tabbing}\item 
\Hypertarget{structchannel_aa2f1ded822da5997689b388848439468}\label{structchannel_aa2f1ded822da5997689b388848439468} 
\begin{tabbing}
xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=\kill
struct \{\\
\>struct sockaddr\_storage {\bfseries dest\_socket}\\
\>pthread\_t {\bfseries thread}\\
\} {\bfseries rtcp}\\

\end{tabbing}\item 
\Hypertarget{structchannel_a43db8c85216bc1cd343e3de7dc5ca07c}\label{structchannel_a43db8c85216bc1cd343e3de7dc5ca07c} 
\begin{tabbing}
xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=\kill
struct \{\\
\>struct sockaddr\_storage {\bfseries dest\_socket}\\
\>pthread\_t {\bfseries thread}\\
\} {\bfseries sap}\\

\end{tabbing}\item 
\Hypertarget{structchannel_a2f357e6e78d9f22c7bb84793f60d2622}\label{structchannel_a2f357e6e78d9f22c7bb84793f60d2622} 
pthread\+\_\+t {\bfseries demod\+\_\+thread}
\item 
\Hypertarget{structchannel_a3b05fec282a4b4fe2af2a89de94212bd}\label{structchannel_a3b05fec282a4b4fe2af2a89de94212bd} 
uint64\+\_\+t {\bfseries options}
\item 
\Hypertarget{structchannel_a5c3602ca42da118e70611356d4cf933b}\label{structchannel_a5c3602ca42da118e70611356d4cf933b} 
float {\bfseries tp1}
\item 
\Hypertarget{structchannel_af58978a1c4c404a539955821338cec18}\label{structchannel_af58978a1c4c404a539955821338cec18} 
float {\bfseries tp2}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
radiod channel state block 

This is primarily for radiod, but it is also used by \textquotesingle{}control\textquotesingle{} and \textquotesingle{}monitor\textquotesingle{} to shadow radiod\textquotesingle{}s state, encoded for network transmission by send\+\_\+radio\+\_\+status() and decoded by decode\+\_\+radio\+\_\+status(). The transfer protocol uses a series of TLV-\/encoded tuples that do {\itshape not} send every element of this structure, so shadow copies can be incomplete.

Be careful with memcpy()\+: there are a few pointers (filter.\+energies, spectrum.\+bin\+\_\+data, status.\+command, etc) If you use these in shadow copies you must malloc these arrays yourself. 

The documentation for this struct was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/\+Users/karn/src/ka9q-\/radio/radio.\+h\end{DoxyCompactItemize}
